(window.webpackJsonp=window.webpackJsonp||[]).push([[225],{695:function(s,t,a){"use strict";a.r(t);var r=a(29),e=Object(r.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"优化docker中的spring-boot应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化docker中的spring-boot应用"}},[s._v("#")]),s._v(" 优化Docker中的Spring Boot应用")]),s._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[s._v("提示")]),s._v(" "),a("p",[s._v("文介绍了如何使用Docker中的一些关键概念和结构组件来优化Spring Boot应用程序。")])]),s._v(" "),a("p",[s._v("Docker功能强大且易于使用。Docker允许开发人员研制的软件创建可移植的镜像。这些镜像可重复地部署。你可以很容易地从Docker中获得很多价值，但是要从Docker中获得最大的价值，需要理解一些概念。在进行持续集成和持续交付时，如何构建Docker镜像具有重要的作用。在本文中，我将重点介绍在进行迭代开发和部署时，如何采用更有效的方法为Spring Boot应用程序构建Docker镜像。为Spring Boot应用程序构建Docker镜像的标准方法有一些缺点，因此在这里我们要介绍如何做得更好。")]),s._v(" "),a("h2",{attrs:{id:"docker关键概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#docker关键概念"}},[s._v("#")]),s._v(" Docker关键概念")]),s._v(" "),a("p",[s._v("Docker有四个关键概念： "),a("code",[s._v("images")]),s._v(", "),a("code",[s._v("layers")]),s._v(", "),a("code",[s._v("Dockerfile")]),s._v(" 和 "),a("code",[s._v("Docker cache")]),s._v("。简而言之，Dockerfile描述了如何构建Docker镜像。镜像由许多层组成。Dockerfile从基础镜像开始，并添加了其他层。当新内容添加到镜像时，将生成一个新层。所构建的每个层都被缓存，因此可以在后续构建中重复使用。当Docker构建运行时，它可以从缓存中获取重复使用任何已有层。这就减少了每次构建所需的时间和空间。任何已更改或以前尚未构建的内容都将根据需要进行构建。")]),s._v(" "),a("p",[a("img",{attrs:{src:"/img/2021-02-18_20-00-46.png",alt:"Docker更新频率"}})]),s._v(" "),a("h2",{attrs:{id:"镜像层内容很重要"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#镜像层内容很重要"}},[s._v("#")]),s._v(" 镜像层内容很重要")]),s._v(" "),a("p",[s._v("镜像各层的重要性。Docker缓存中的现有层，只有当改镜像层内容没有变更时，才能被使用。在Docker构建期间更改的层越多，Docker需要执行更多的工作来重建镜像。镜像层顺序也很重要。如果某个图层的所有父图层均未更改，则该图层就能被重用。因此，最好把比较频繁更改的图层放在上面，以便对其更改会影响较少的子图层。")]),s._v(" "),a("p",[s._v("镜像层的顺序和内容很重要。当你把应用程序打包为Docker镜像时，最简单的方法是将整个应用程序放置到一个单独的镜像层中。但是，如果该应用程序包含大量静态库依赖，那么即使更改很少的代码，也需要重新构建整个镜像层。这就需要在Docker缓存中，花费大量构建时间和空间。")]),s._v(" "),a("h2",{attrs:{id:"镜像层影响部署"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#镜像层影响部署"}},[s._v("#")]),s._v(" 镜像层影响部署")]),s._v(" "),a("p",[s._v("部署Docker镜像时，镜像层也很重要。在部署Docker镜像之前，它们会被推送到Docker远程仓库。该仓库是所有部署镜像的源头，并且经常包含同一镜像的许多版本。Docker非常高效，每个层仅存储一次。但是，对于频繁部署且具有不断重建的大体积层的镜像，这就不行了。大体积层的镜像，即使内部只有很少的更改，也必须单独存储在仓库中并在网络中推送。因为需要移动并存储不变的内容，这就会增加部署时间，")]),s._v(" "),a("h2",{attrs:{id:"docker中的spring-boot应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#docker中的spring-boot应用"}},[s._v("#")]),s._v(" Docker中的Spring Boot应用")]),s._v(" "),a("p",[s._v("使用uber-jar方法的Spring Boot应用程序本身就是独立的部署单元。该模型非常适合在虚拟机或构建包上进行部署，因为该应用程序可带来所需的一切。但是，这对Docker部署是一个缺点：Docker已经提供了打包依赖项的方法。将整个Spring Boot JAR放入Docker镜像是很常见的，但是，这会导致Docker镜像的应用程序层中的不变内容太多。")]),s._v(" "),a("p",[a("img",{attrs:{src:"/img/2021-02-18_20-00-47.png",alt:"Java SpringBoot单层"}})]),s._v(" "),a("p",[s._v("Spring社区中正在进行有关减少运行Spring Boot应用程序时的部署大小和时间的讨论，尤其是在Docker中。在我看来，这最终是在简单性与效率之间进行权衡。为Spring Boot应用程序构建Docker镜像的最常见方法是我所说的“单层”方法。从技术上讲，这不是正确的，因为Dockerfile实际上创建了多个层，但是对于讨论来说已经足够了。")]),s._v(" "),a("h2",{attrs:{id:"单层方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单层方法"}},[s._v("#")]),s._v(" 单层方法")]),s._v(" "),a("p",[s._v("让我们看一下单层方法。单层方法快速，简单，易于理解和使用。"),a("a",{attrs:{href:"https://github.com/spring-guides/gs-spring-boot-docker",target:"_blank",rel:"noopener noreferrer"}},[s._v("Docker的Spring Boot指南"),a("OutboundLink")],1),s._v(" 列出了单层Dockerfile来构建你的Docker镜像：")]),s._v(" "),a("div",{staticClass:"language-dockerfile extra-class"},[a("pre",{pre:!0,attrs:{class:"language-dockerfile"}},[a("code",[a("span",{pre:!0,attrs:{class:"token instruction"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" openjdk:8-jdk-alpine")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token instruction"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("VOLUME")]),s._v(" /tmp")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token instruction"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("ARG")]),s._v(" JAR_FILE")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token instruction"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("COPY")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[s._v("${JAR_FILE}")]),s._v(" app.jar")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token instruction"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("ENTRYPOINT")]),s._v(" ["),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"java"')]),s._v(","),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"-Djava.security.egd=file:/dev/./urandom"')]),s._v(","),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"-jar"')]),s._v(","),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"/app.jar"')]),s._v("]")]),s._v("\n")])])]),a("p",[s._v("它的最终结果是一个正常运行的Docker镜像，其运行方式与你期望Spring Boot应用程序运行的方式完全相同。但是，由于它基于整个应用程序JAR，因此存在分层效率问题。随着应用程序源的更改，整个Spring Boot JAR都会被重建。下次构建Docker镜像时，将重新构建整个应用程序层，包括所有不变的依赖库。")]),s._v(" "),a("p",[s._v("让我们看一个具体的例子， "),a("a",{attrs:{href:"https://github.com/spring-projects/spring-petclinic",target:"_blank",rel:"noopener noreferrer"}},[s._v("Spring Pet Clinic"),a("OutboundLink")],1),s._v("。")]),s._v(" "),a("h2",{attrs:{id:"更深入地研究单层方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更深入地研究单层方法"}},[s._v("#")]),s._v(" 更深入地研究单层方法")]),s._v(" "),a("p",[s._v("单层方法使用Open Boot JDK基础镜像之上的Spring Boot JAR作为Docker层构建Docker镜像：")]),s._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("$ "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("docker")]),s._v(" images\nREPOSITORY                    TAG         IMAGE ID            CREATED             SIZE\nspringio/spring-petclinic     latest      94b0366d5ba2        "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("16")]),s._v(" seconds ago      140MB\n")])])]),a("p",[s._v("生成的Docker镜像为140 MB。你可以使用docker history 命令检查图层 。你可以看到Spring Boot应用程序JAR已复制到镜像中，大小为38.3 MB。")]),s._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("$ "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("docker")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("history")]),s._v(" springio/spring-petclinic\nIMAGE               CREATED             CREATED BY                                      SIZE                COMMENT\n94b0366d5ba2        "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("52")]),s._v(" seconds ago      /bin/sh -c "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v('#(nop)  ENTRYPOINT ["java" "-Djav…   0B')]),s._v("\n213dff56a4bd        "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("53")]),s._v(" seconds ago      /bin/sh -c "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#(nop) COPY file:d3551559c2aa35af…   38.3MB")]),s._v("\nbc453a32748e        "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("6")]),s._v(" minutes ago       /bin/sh -c "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#(nop)  ARG JAR_FILE                 0B")]),s._v("\n7fe0bb0d8026        "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("6")]),s._v(" minutes ago       /bin/sh -c "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#(nop)  VOLUME [/tmp]                0B")]),s._v("\ncc2179b8f042        "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("8")]),s._v(" days ago          /bin/sh -c "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("set")]),s._v(" -x  "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("&&")]),s._v(" apk "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("add")]),s._v(" --no-cache   o…   "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("97")]),s._v(".4MB\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("missing"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("           "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("8")]),s._v(" days ago          /bin/sh -c "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#(nop)  ENV JAVA_ALPINE_VERSION=8…   0B")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("missing"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("           "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("8")]),s._v(" days ago          /bin/sh -c "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#(nop)  ENV JAVA_VERSION=8u151       0B")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("missing"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("           "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("8")]),s._v(" days ago          /bin/sh -c "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#(nop)  ENV PATH=/usr/local/sbin:…   0B")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("missing"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("           "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("8")]),s._v(" days ago          /bin/sh -c "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#(nop)  ENV JAVA_HOME=/usr/lib/jv…   0B")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("missing"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("           "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("8")]),s._v(" days ago          /bin/sh -c "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("   "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("echo")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'#!/bin/sh'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("   "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("echo")]),s._v(" 'set…   87B\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("missing"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("           "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("8")]),s._v(" days ago          /bin/sh -c "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#(nop)  ENV LANG=C.UTF-8             0B")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("missing"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("           "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("5")]),s._v(" months ago        /bin/sh -c "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v('#(nop)  CMD ["/bin/sh"]              0B')]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("missing"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("           "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("5")]),s._v(" months ago        /bin/sh -c "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("#(nop) ADD file:093f0723fa46f6cdb…   4.15MB")]),s._v("\n")])])]),a("p",[s._v("下次构建Docker镜像时，将重新创建整个38 MB的层，因为重新打包了JAR文件。")]),s._v(" "),a("p",[s._v("在此示例中，应用程序的大小相对较小（因为仅基于spring-boot-starter-web和其他依赖项，例如spring-actuator）。在实际开发中，这些大小通常要大得多，因为它们不仅包括Spring Boot库，还包括其他第三方库。根据我的经验，实际的Spring Boot应用程序的大小范围可能在50 MB到250 MB之间（如果不是更大的话）。")]),s._v(" "),a("p",[s._v("仔细观察该应用程序，应用程序JAR中只有372 KB是应用程序代码。其余38 MB是依赖库。这意味着实际上只有0.1％的层在变化。其余99.9％不变。")]),s._v(" "),a("h2",{attrs:{id:"镜像层生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#镜像层生命周期"}},[s._v("#")]),s._v(" 镜像层生命周期")]),s._v(" "),a("p",[s._v("这是基于镜像层的基本考虑：内容的生命周期。镜像层的内容应具有相同的生命周期。Spring Boot应用程序的内容有两个不同的生命周期：不经常更改的依赖库和经常更改的应用程序类。")]),s._v(" "),a("p",[s._v("每次由于应用程序代码更改而重建该层时，也会包含不变的二进制文件。在快速的应用程序开发环境中，不断更改和重新部署应用程序代码，这种附加成本可能变得非常昂贵。")]),s._v(" "),a("p",[s._v("想象一个应用团队在Pet Clinic上进行迭代。团队每天更改和重新部署应用程序10次。这10个新层的成本为每天383 MB。如果使用更多实际大小，则每天最多可以达到2.5 GB或更多。最终将浪费大量的构建时间，部署时间和Docker仓库空间。")]),s._v(" "),a("p",[s._v("快速迭代的开发和交付是决定我们是继续使用简单的单层方法，还是采用更有效的替代方法。")]),s._v(" "),a("h2",{attrs:{id:"拥抱docker-进入双层"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#拥抱docker-进入双层"}},[s._v("#")]),s._v(" 拥抱Docker，进入双层")]),s._v(" "),a("p",[s._v("在简单性和效率之间进行权衡时，我认为正确的选择是“双层”方法。（可以有更多的层，但是太多的层可能有害，并且违反了 "),a("a",{attrs:{href:"https://docs.docker.com/develop/develop-images/dockerfile_best-practices/",target:"_blank",rel:"noopener noreferrer"}},[s._v("Docker最佳实践"),a("OutboundLink")],1),s._v("）。在双层方法中，我们构建Docker镜像，以使Spring Boot应用程序的依赖库，存在于应用程序代码下方的一层中。这样，各层将遵循内容的不同生命周期。通过将不经常更改的依赖库推入一个单独的层，并仅将应用程序类保留在顶层，那么迭代重建和重新部署就会更快。")]),s._v(" "),a("p",[a("img",{attrs:{src:"/img/2021-02-18_20-00-48.png",alt:"Java Spring Boot双层"}})]),s._v(" "),a("p",[s._v("双层方法加快了迭代开发的速度，并最大程度地缩短了部署时间。当然实际效率因应用程序而异，但是平均而言，这将使应用程序部署大小减少90％，同时相应地缩短了部署周期。")])])}),[],!1,null,null,null);t.default=e.exports}}]);