(window.webpackJsonp=window.webpackJsonp||[]).push([[204],{673:function(t,e,l){"use strict";l.r(e);var a=l(29),_=Object(a.a)({},(function(){var t=this,e=t.$createElement,l=t._self._c||e;return l("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[l("h1",{attrs:{id:"软件工程介绍"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#软件工程介绍"}},[t._v("#")]),t._v(" 软件工程介绍")]),t._v(" "),l("h2",{attrs:{id:"软件开发生命周期-sdlc"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#软件开发生命周期-sdlc"}},[t._v("#")]),t._v(" 软件开发生命周期 (SDLC)")]),t._v(" "),l("p",[t._v("软件开发生命周期又叫做"),l("strong",[t._v("SDLC")]),t._v("(Software Development Life Cycle)，它是集合了计划、开发、测试 和部署过程的集合。如下图所示 :")]),t._v(" "),l("p",[l("img",{attrs:{src:"/img/2021-06-14_16-25-07.jpg",alt:"Software Development Life Cycle"}})]),t._v(" "),l("h3",{attrs:{id:"计划和需求分析-planning-and-requirement-analysis"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#计划和需求分析-planning-and-requirement-analysis"}},[t._v("#")]),t._v(" 计划和需求分析 (Planning and Requirement Analysis)")]),t._v(" "),l("p",[t._v("每个软件开发生命周期模型都从分析开始，过程的利益相关者讨论对最终产品的要求。此阶段的目标是系统要求的详细定义。此外，还需要确保所有流程参与者都清楚地了解任务以及每个需求将如何实施。通常，讨论涉及质量保证专家，如果有必要，他们甚至可以在开发阶段干预过程中的添加。")]),t._v(" "),l("h3",{attrs:{id:"设计项目架构-project-architecture"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#设计项目架构-project-architecture"}},[t._v("#")]),t._v(" 设计项目架构 (Project Architecture)")]),t._v(" "),l("p",[t._v("在软件开发生命周期的第二阶段，开发人员实际上正在设计架构。所有利益相关者（包括客户）都会讨论此阶段可能出现的所有不同技术问题。此外，还定义了项目中使用的技术，团队负载，限制，时间范围和预算。最合适的项目决策是根据定义的要求做出的。")]),t._v(" "),l("h3",{attrs:{id:"开发和编程-development-and-coding"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#开发和编程-development-and-coding"}},[t._v("#")]),t._v(" 开发和编程 (Development and Coding)")]),t._v(" "),l("p",[t._v("在批准要求后，该过程进入下一阶段 - 实际开发。程序员从这里开始编写源代码，同时牢记先前定义的需求。系统管理员调整软件环境，前端程序员开发程序的用户界面以及与服务器交互的逻辑。\n编程本身假设有四个阶段")]),t._v(" "),l("ul",[l("li",[t._v("算法开发")]),t._v(" "),l("li",[t._v("源代码编写")]),t._v(" "),l("li",[t._v("汇编")]),t._v(" "),l("li",[t._v("测试和调试")])]),t._v(" "),l("h3",{attrs:{id:"测试-testing"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#测试-testing"}},[t._v("#")]),t._v(" 测试 (Testing)")]),t._v(" "),l("p",[t._v("测试阶段包括调试过程。开发过程中遗漏的所有代码缺陷都会在此处检测到，记录下来并传回给开发人员进行修复。重复测试过程，直到删除所有关键问题并且软件工作流程稳定。")]),t._v(" "),l("h3",{attrs:{id:"部署-deployment"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#部署-deployment"}},[t._v("#")]),t._v(" 部署 (Deployment)")]),t._v(" "),l("p",[t._v("当程序最终确定并且没有关键问题时 - 是时候为最终用户启动它了。新程序版本发布后，技术支持团队加入。该部门提供用户反馈; 在利用期间咨询和支持用户。此外，此阶段还包括所选组件的更新，以确保软件是最新的，并且不会受到安全漏洞的影响。")]),t._v(" "),l("h2",{attrs:{id:"sdlc模型-software-development-lifecycle-model"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#sdlc模型-software-development-lifecycle-model"}},[t._v("#")]),t._v(" SDLC模型 (Software Development Lifecycle Model)")]),t._v(" "),l("p",[t._v("从第一个也是最古老的“瀑布式”SDLC模型演变而来，它们的种类显着扩大。SDLC模型的多样性由众多产品类型预先确定 - 从简单的网站到复杂的医疗软件。如果你采用下面提到的SDLC模型之一作为基础 - 无论如何，它应该根据产品，项目和公司的特征进行调整。下面给出了最常用，最受欢迎和最重要的SDLC模型：")]),t._v(" "),l("ul",[l("li",[l("a",{attrs:{href:"https://en.wikipedia.org/wiki/Waterfall_model",target:"_blank",rel:"noopener noreferrer"}},[t._v("瀑布模型"),l("OutboundLink")],1),t._v(" (Waterfall Model)")]),t._v(" "),l("li",[l("a",{attrs:{href:"https://en.wikipedia.org/wiki/Iterative_and_incremental_development",target:"_blank",rel:"noopener noreferrer"}},[t._v("迭代模型"),l("OutboundLink")],1),t._v(" (Iterative Model)")]),t._v(" "),l("li",[l("a",{attrs:{href:"https://en.wikipedia.org/wiki/Spiral_model",target:"_blank",rel:"noopener noreferrer"}},[t._v("螺旋模型"),l("OutboundLink")],1),t._v(" (Spiral Model)")]),t._v(" "),l("li",[l("a",{attrs:{href:"https://en.wikipedia.org/wiki/V-Model_(software_development)",target:"_blank",rel:"noopener noreferrer"}},[t._v("V形模型"),l("OutboundLink")],1),t._v(" (V-Shape Model)")]),t._v(" "),l("li",[l("a",{attrs:{href:"https://en.wikipedia.org/wiki/Agile_software_development",target:"_blank",rel:"noopener noreferrer"}},[t._v("敏捷模型"),l("OutboundLink")],1),t._v(" (Agile Model)")])]),t._v(" "),l("h3",{attrs:{id:"瀑布sdlc模型"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#瀑布sdlc模型"}},[t._v("#")]),t._v(" 瀑布SDLC模型")]),t._v(" "),l("p",[t._v("瀑布 - 是一个级联SDLC模型，其中开发过程看起来像流程，一步一步地进行分析，预测，实现，测试，实施和支持阶段。该SDLC模型包括完全逐步执行每个阶段。该过程严格记录并预定义，具有该软件开发生命周期模型的每个阶段所期望的功能。")]),t._v(" "),l("p",[l("img",{attrs:{src:"/img/2021-06-17_235208.png",alt:"Waterfall SDLC Model Scheme"}})]),t._v(" "),l("table",[l("thead",[l("tr",[l("th",{staticStyle:{"text-align":"left"}},[t._v("好处")]),t._v(" "),l("th",{staticStyle:{"text-align":"left"}},[t._v("劣势")])])]),t._v(" "),l("tbody",[l("tr",[l("td",{staticStyle:{"text-align":"left"}},[t._v("简单易用和理解")]),t._v(" "),l("td",{staticStyle:{"text-align":"left"}},[t._v("只有在最后一个阶段结束后，软件才会准备就绪")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"left"}},[t._v("由于其刚性，管理简单：每个阶段都有明确的结果和流程审查")]),t._v(" "),l("td",{staticStyle:{"text-align":"left"}},[t._v("高风险和不确定性")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"left"}},[t._v("发展阶段逐一进行")]),t._v(" "),l("td",{staticStyle:{"text-align":"left"}},[t._v("不是复杂和面向对象项目的最佳选择")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"left"}},[t._v("适用于要求明确且不模棱两可的小型或中型项目")]),t._v(" "),l("td",{staticStyle:{"text-align":"left"}},[t._v("不适合长期项目")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"left"}},[t._v("易于确定开发周期中的关键点")]),t._v(" "),l("td",{staticStyle:{"text-align":"left"}},[t._v("阶段的进展很难衡量，但仍处于发展阶段")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"left"}},[t._v("易于分类和确定任务的优先级")]),t._v(" "),l("td",{staticStyle:{"text-align":"left"}},[t._v("集成在最后完成，不提供预先识别问题的选项")])])])]),t._v(" "),l("p",[l("strong",[t._v("Waterfall SDLC模型的用例：")])]),t._v(" "),l("ul",[l("li",[t._v("准确记录了这些要求")]),t._v(" "),l("li",[t._v("产品定义稳定")]),t._v(" "),l("li",[t._v("技术堆栈是预定义的，这使得它不是动态的")]),t._v(" "),l("li",[t._v("没有模棱两可的要求")]),t._v(" "),l("li",[t._v("该项目很短")])]),t._v(" "),l("h3",{attrs:{id:"迭代sdlc模型"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#迭代sdlc模型"}},[t._v("#")]),t._v(" 迭代SDLC模型")]),t._v(" "),l("p",[t._v("在项目开始之前，迭代SDLC模型不需要完整的需求列表。开发过程可以从对功能部件的要求开始，可以在以后扩展。该过程是重复的，允许为每个循环制作新版本的产品。每次迭代（持续两到六周）都包括开发系统的单独组件，然后，将此组件添加到之前开发的功能中。说到数学术语，迭代模型是顺序逼近方法的实现; 这意味着逐渐接近计划的最终产品形状。")]),t._v(" "),l("p",[l("img",{attrs:{src:"/img/2021-06-17_135208.png",alt:"Iterative SDLC Model Scheme"}})]),t._v(" "),l("table",[l("thead",[l("tr",[l("th",{staticStyle:{"text-align":"left"}},[t._v("好处")]),t._v(" "),l("th",{staticStyle:{"text-align":"left"}},[t._v("劣势")])])]),t._v(" "),l("tbody",[l("tr",[l("td",{staticStyle:{"text-align":"left"}},[t._v("某些功能可以在开发生命周期的开始阶段快速开发")]),t._v(" "),l("td",{staticStyle:{"text-align":"left"}},[t._v("迭代模型比瀑布模型需要更多资源")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"left"}},[t._v("可以应用并行开发")]),t._v(" "),l("td",{staticStyle:{"text-align":"left"}},[t._v("需要持续管理")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"left"}},[t._v("进展很容易衡量")]),t._v(" "),l("td",{staticStyle:{"text-align":"left"}},[t._v("可能会出现架构或设计问题，因为在短期规划阶段并未预见到所有要求")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"left"}},[t._v("较短的迭代是 - 更容易的测试和调试阶段")]),t._v(" "),l("td",{staticStyle:{"text-align":"left"}},[t._v("小项目的糟糕选择")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"left"}},[t._v("由于首先完成高风险任务，因此更容易控制风险")]),t._v(" "),l("td",{staticStyle:{"text-align":"left"}},[t._v("这个过程很难管理")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"left"}},[t._v("在下一个sprint中可以防止在一次迭代中定义的问题和风险")]),t._v(" "),l("td",{staticStyle:{"text-align":"left"}},[t._v("即使在项目的最后阶段，风险也可能无法完全确定")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"left"}},[t._v("灵活性和准备变化的要求")]),t._v(" "),l("td",{staticStyle:{"text-align":"left"}},[t._v("风险分析需要高素质专家的参与")])])])]),t._v(" "),l("p",[l("strong",[t._v("迭代模型的用例：")])]),t._v(" "),l("ul",[l("li",[t._v("最终产品的要求是严格预定义的")]),t._v(" "),l("li",[t._v("适用于大型项目")]),t._v(" "),l("li",[t._v("主要任务是预定义的，但细节可能随着时间而推进")])]),t._v(" "),l("h3",{attrs:{id:"螺旋sdlc模型"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#螺旋sdlc模型"}},[t._v("#")]),t._v(" 螺旋SDLC模型")]),t._v(" "),l("p",[t._v("螺旋模型 - 是SDLC模型，它分阶段结合了架构和原型。它是Iterative和Waterfall SDLC模型的组合，具有重要的风险分析重点。螺旋模型的主要问题是确定进入下一阶段的正确时机。建议将初步设定的时间范围作为此问题的解决方案。即使前一阶段的工作尚未完成，也将根据计划完成向下一阶段的转变。该计划是根据统计数据引入的，即使从个人开发人员的经验来看，也可以在之前的项目中收到。")]),t._v(" "),l("p",[l("img",{attrs:{src:"/img/2021-06-17_335208.png",alt:"èºæSDLCæ¨¡åæ¹æ¡"}})]),t._v(" "),l("table",[l("thead",[l("tr",[l("th",{staticStyle:{"text-align":"left"}},[t._v("好处")]),t._v(" "),l("th",{staticStyle:{"text-align":"left"}},[t._v("劣势")])])]),t._v(" "),l("tbody",[l("tr",[l("td",{staticStyle:{"text-align":"left"}},[t._v("生命周期分为小部分，如果风险集中度较高，则可以提前完成阶段以解决问题")]),t._v(" "),l("td",{staticStyle:{"text-align":"left"}},[t._v("可能相当昂贵")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"left"}},[t._v("开发过程准确记录，可根据变化进行扩展")]),t._v(" "),l("td",{staticStyle:{"text-align":"left"}},[t._v("风险控制需要高技能专业人员的参与")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"left"}},[t._v("可伸缩性允许在相对较晚的阶段进行更改并添加新功能")]),t._v(" "),l("td",{staticStyle:{"text-align":"left"}},[t._v("对小项目可能无效")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"left"}},[t._v("早期的工作原型已经完成 - 用户可以更快地指出这些缺陷")]),t._v(" "),l("td",{staticStyle:{"text-align":"left"}},[t._v("大量的中间阶段需要过多的文档")])])])]),t._v(" "),l("p",[l("strong",[t._v("旋模型的用例")])]),t._v(" "),l("ul",[l("li",[t._v("客户不确定要求")]),t._v(" "),l("li",[t._v("预计在开发周期中会进行重大编辑")]),t._v(" "),l("li",[t._v("具有中级或高级风险的项目，防止这些风险非常重要")]),t._v(" "),l("li",[t._v("应该在几个阶段发布的新产品，以获得足够的客户反馈")])]),t._v(" "),l("h3",{attrs:{id:"v形sdlc模型"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#v形sdlc模型"}},[t._v("#")]),t._v(" V形SDLC模型")]),t._v(" "),l("p",[t._v("V形SDLC模型是经典瀑布模型的扩展，它基于每个开发阶段的相关测试阶段。这是一个非常严格的模型，下一阶段仅在前一阶段之后开始。这也称为“验证和验证”模型。每个阶段都有当前的过程控制，以确保可以转换到下一个阶段。")]),t._v(" "),l("p",[l("img",{attrs:{src:"/img/2021-06-17_435208.png",alt:"Vå½¢SDLCæ¨¡åæ¹æ¡"}})]),t._v(" "),l("table",[l("thead",[l("tr",[l("th",{staticStyle:{"text-align":"left"}},[t._v("好处")]),t._v(" "),l("th",{staticStyle:{"text-align":"left"}},[t._v("劣势")])])]),t._v(" "),l("tbody",[l("tr",[l("td",{staticStyle:{"text-align":"left"}},[t._v("V形模型的每个阶段都有严格的结果，因此很容易控制")]),t._v(" "),l("td",{staticStyle:{"text-align":"left"}},[t._v("缺乏灵活性")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"left"}},[t._v("测试和验证在早期阶段进行")]),t._v(" "),l("td",{staticStyle:{"text-align":"left"}},[t._v("小项目的糟糕选择")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"left"}},[t._v("适用于需求稳定且清晰的小型项目")]),t._v(" "),l("td",{staticStyle:{"text-align":"left"}},[t._v("相对较大的风险")])])])]),t._v(" "),l("p",[l("strong",[t._v("V形模型的用例：")])]),t._v(" "),l("ul",[l("li",[t._v("对于需要进行准确产品测试的项目")]),t._v(" "),l("li",[t._v("适用于中小型项目，其中严格要求严格要求")]),t._v(" "),l("li",[t._v("获得所需资格的工程师，特别是测试人员，可轻松到达。")])]),t._v(" "),l("h3",{attrs:{id:"敏捷sdlc模型"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#敏捷sdlc模型"}},[t._v("#")]),t._v(" 敏捷SDLC模型")]),t._v(" "),l("p",[t._v("在每次开发迭代之后的敏捷方法中，客户能够看到结果并理解他是否满意或不满意。这是敏捷软件开发生命周期模型的优势之一。其缺点之一是，由于缺乏明确的要求，很难估计资源和开发成本。极限编程是敏捷模型的实际应用之一。这种模型的基础包括每周短暂的会议 - Sprint是Scrum方法的一部分。")]),t._v(" "),l("p",[l("img",{attrs:{src:"/img/2021-06-17_535208.png",alt:"ææ·SDLCæ¨¡åæ¹æ¡"}})]),t._v(" "),l("table",[l("thead",[l("tr",[l("th",{staticStyle:{"text-align":"left"}},[t._v("好处")]),t._v(" "),l("th",{staticStyle:{"text-align":"left"}},[t._v("劣势")])])]),t._v(" "),l("tbody",[l("tr",[l("td",{staticStyle:{"text-align":"left"}},[t._v("功能需求的更正被实施到开发过程中以提供竞争力")]),t._v(" "),l("td",{staticStyle:{"text-align":"left"}},[t._v("由于永久性变化而无法衡量最终成本")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"left"}},[t._v("项目按短而透明的迭代划分")]),t._v(" "),l("td",{staticStyle:{"text-align":"left"}},[t._v("团队应该是高度专业和客户导向的")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"left"}},[t._v("灵活的变更过程使风险最小化")]),t._v(" "),l("td",{staticStyle:{"text-align":"left"}},[t._v("新要求可能与现有架构冲突")])]),t._v(" "),l("tr",[l("td",{staticStyle:{"text-align":"left"}},[t._v("快速发布第一个产品版本")]),t._v(" "),l("td",{staticStyle:{"text-align":"left"}},[t._v("通过所有更正和更改，项目可能会超出预期时间")])])])]),t._v(" "),l("p",[l("strong",[t._v("敏捷模型的用例：")])]),t._v(" "),l("ul",[l("li",[t._v("用户需求动态变化")]),t._v(" "),l("li",[t._v("由于许多迭代，实施的更改的价格更低")]),t._v(" "),l("li",[t._v("与瀑布模型不同，它只需要初始计划来启动项目")])])])}),[],!1,null,null,null);e.default=_.exports}}]);