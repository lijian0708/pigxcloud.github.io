(window.webpackJsonp=window.webpackJsonp||[]).push([[202],{671:function(s,t,e){"use strict";e.r(t);var n=e(29),o=Object(n.a)({},(function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"分布式认证方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式认证方案"}},[s._v("#")]),s._v(" 分布式认证方案")]),s._v(" "),e("h2",{attrs:{id:"基于session的认证方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基于session的认证方式"}},[s._v("#")]),s._v(" 基于session的认证方式")]),s._v(" "),e("p",[s._v("在分布式的环境下，基于session的认证会出现一个问题，每个应用服务都需要在session中存储用户身份信息，通\n过负载均衡将本地的请求分配到另一个应用服务需要将session信息带过去，否则会重新认证。")]),s._v(" "),e("p",[e("img",{attrs:{src:"/img/2020-11-01_20-58-12.png",alt:"基于session的认证方式"}})]),s._v(" "),e("p",[s._v("这个时候，通常的做法有下面几种:")]),s._v(" "),e("ul",[e("li",[e("strong",[s._v("Session复制")]),s._v("：多台应用服务器之间同步session，使session保持一致，对外透明。")]),s._v(" "),e("li",[e("strong",[s._v("Session黏贴")]),s._v("：当用户访问集群中某台服务器后，强制指定后续所有请求均落到此机器上。")]),s._v(" "),e("li",[e("strong",[s._v("Session集中存储")]),s._v("：将Session存入分布式缓存中，所有服务器应用实例统一从分布式缓存中存取Session。")])]),s._v(" "),e("p",[s._v("总体来讲，基于session认证的认证方式，可以更好的在服务端对会话进行控制，且安全性较高。但是，session机 制方式基于cookie，在复杂多样的移动客户端上不能有效的使用，并且无法跨域，另外随着系统的扩展需提高 session的复制、黏贴及存储的容错性。")]),s._v(" "),e("h2",{attrs:{id:"基于token的认证方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基于token的认证方式"}},[s._v("#")]),s._v(" 基于token的认证方式")]),s._v(" "),e("p",[s._v("基于token的认证方式，服务端不用存储认证数据，易维护扩展性强， 客户端可以把token 存在任意地方，并且可 以实现web和app统一认证机制。其缺点也很明显，token由于自包含信息，因此一般数据量较大，而且每次请求 都需要传递，因此比较占带宽。另外，token的签名验签操作也会给cpu带来额外的处理负担。")]),s._v(" "),e("p",[e("img",{attrs:{src:"/img/2020-11-01_21-04-03.png",alt:"基于session的认证方式"}})])])}),[],!1,null,null,null);t.default=o.exports}}]);