(window.webpackJsonp=window.webpackJsonp||[]).push([[108],{578:function(v,_,t){"use strict";t.r(_);var a=t(29),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"rabbitmq-简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq-简介"}},[v._v("#")]),v._v(" RabbitMQ 简介")]),v._v(" "),t("p",[v._v("在介绍RabbitMQ之前，我们先来看下面一个电商项目的场景：")]),v._v(" "),t("ul",[t("li",[v._v("商品的原始数据保存在数据库中，增删改查都在数据库中完成。")]),v._v(" "),t("li",[v._v("搜索服务数据来源是索引库 Elasticsearch，如果数据库商品发生变化，索引库数据不能及时更新。")]),v._v(" "),t("li",[v._v("商品详情做了页面静态化处理，静态页面数据也不会随着数据库商品更新而变化。")])]),v._v(" "),t("p",[v._v("如果我们在后台修改了商品的价格，搜索页面和商品详情页显示的依然是旧的价格，这样显然不对。该如何解决？")]),v._v(" "),t("p",[v._v("我们可能会想到这么做：")]),v._v(" "),t("ul",[t("li",[v._v("方案1：每当后台对商品做增删改操作，同时修改索引库数据及更新静态页面。")]),v._v(" "),t("li",[v._v("方案2：搜索服务和商品页面静态化服务对外提供操作接口，后台在商品增删改后，调用接口。")])]),v._v(" "),t("p",[v._v("这两种方案都有个严重的问题：就是代码耦合，后台服务中需要嵌入搜索和商品页面服务，违背了微服务的独立原则。")]),v._v(" "),t("p",[v._v("这时，我们就会采用另外一种解决办法，那就是"),t("strong",[v._v("消息队列")]),v._v("！")]),v._v(" "),t("p",[v._v("商品服务对商品增删改以后，无需去操作索引库和静态页面，只需向MQ发送一条消息（比如包含商品id的消息），也不关心消息被谁接收。搜索服务和静态页面服务监听MQ，接收消息，然后分别去处理索引库和静态页面（根据商品id去更新索引库和商品详情静态页面）。")]),v._v(" "),t("h2",{attrs:{id:"什么是消息队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是消息队列"}},[v._v("#")]),v._v(" 什么是消息队列")]),v._v(" "),t("p",[v._v("MQ全称为Message Queue，即消息队列 。“消息队列”是在消息的传输过程中保存消息的容器。它是典型的：生产者、消费者模型。生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，这样就实现了生产者和消费者的解耦。")]),v._v(" "),t("h2",{attrs:{id:"消息队列应用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消息队列应用场景"}},[v._v("#")]),v._v(" 消息队列应用场景")]),v._v(" "),t("p",[t("strong",[v._v("1、任务异步处理：")])]),v._v(" "),t("p",[v._v("高并发环境下，由于来不及同步处理，请求往往会发生堵塞，比如说，大量的insert，update之类的请求同时到达MySQL，直接导致无数的行锁表锁，甚至最后请求会堆积过多，从而触发too many connections错误。通过使用消息队列，我们可以异步处理请求，从而缓解系统的压力。将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。减少了应用程序的响应时间。")]),v._v(" "),t("p",[t("strong",[v._v("2、应用程序解耦合：")])]),v._v(" "),t("p",[v._v("MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。")]),v._v(" "),t("h2",{attrs:{id:"amqp和jms"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#amqp和jms"}},[v._v("#")]),v._v(" AMQP和JMS")]),v._v(" "),t("p",[v._v("MQ是消息通信的模型，并发具体实现。现在实现MQ的有两种主流方式：AMQP、JMS。")]),v._v(" "),t("p",[t("strong",[v._v("两者间的区别和联系：")])]),v._v(" "),t("ul",[t("li",[v._v("JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式")]),v._v(" "),t("li",[v._v("JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。")]),v._v(" "),t("li",[v._v("JMS规定了两种消息模型；而AMQP的消息模型更加丰富")])]),v._v(" "),t("h2",{attrs:{id:"常见mq产品"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常见mq产品"}},[v._v("#")]),v._v(" 常见MQ产品")]),v._v(" "),t("ul",[t("li",[v._v("ActiveMQ：基于JMS")]),v._v(" "),t("li",[v._v("RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好")]),v._v(" "),t("li",[v._v("RocketMQ：基于JMS，阿里巴巴产品，目前交由Apache基金会")]),v._v(" "),t("li",[v._v("Kafka：分布式消息系统，高吞吐量")])])])}),[],!1,null,null,null);_.default=s.exports}}]);